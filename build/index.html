<!DOCTYPE html>
<html>
  <head>
    <title></title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link href="remark.css" rel="stylesheet" />
    <style type="text/css">
      
    </style>
  </head>
  <body>
    <textarea id="source">name: FP
layout: true
class:

---
# Introduction to Functional Programming

.subheader[Šarūnas Valaškevičius, 2018]
---
## What to expect

- an overview of Functional Programming and basic concepts
- basic Haskell syntax (yes, we'll use Haskell!)
- being able to build a program!

---
## Why Haskell?

- It's purely functional, so it's easier to identify the concepts being explained.
- Paradigm concepts are easily translated to other languages, such as Scala
- Because it's awesome
- It does not allow you to shoot yourself in the foot
- Because it's elegant and clean, it becomes easy to read once you know the
  minimal syntax

---
## Functional programming

Simply put, it is programming with functions.

A function is:

- a description of a computation (a mapping from its input values to an output value);
- a value that can be passed over (or be returned from) to another function.

```Haskell
myFunction :: Arg1Type -> Arg2Type -> ... -> ReturnType
myFunction arg1 arg2 ... = body
```

We can call the function like this:

```Haskell
myFunction arg1 arg2
```

Functions can also be *pure* and *total*.

---
## Pure functions
A function where the return value can only be affected by its input parameters, and it does not
produce any observable side-effect is called a *pure* function - the only effect of the function is
the produced return value.

- this property is called *referential transparency*
- it allows *equational reasoning*:

```Haskell
y = f x
g y == g (f x)
```

Or, if we know that `f x` is 42, we could simply replace `g y` with `g 42` and be sure that the
program still works exactly the same.

---
## Total functions
A function is called *total* when it has a return value for every combination of its possible
input values.

For example, a total function could look like this:
```Haskell
f :: Integer -> Integer
f x = 2*x
```

Another example, where the function is only defined for just some input values, is **not** a total function:

```Haskell
f :: Integer -> Integer -> Integer
f x y = x `div` y
```

Let's try:

```
> f 4 2
2
> f 4 0
*** Exception: divide by zero
```

---
## Defining data types

```Haskell
data MyType = MyIntType Int | MyEmptyType | MyStringType String
```

Defines a new type `MyType` and provides three alternative data constructors:
 - `MyIntType` has one Integer parameter
 - `MyEmptyType` has no parameters
 - `MyStringType` has one String parameter


```Haskell
> let x = MyIntType 1
> :type x
x :: MyType
```

---
## Defining data types

Types can also take type parameters:

```haskell
data  Maybe a  =  Nothing | Just a
```

This type `Maybe` defines a type that can either by `Nothing`, or `Just a`, where `a` is given when creating the `Maybe` type e.g.

```haskell
> :t Just 'a'
Just 'a' :: Maybe Char
```

---
## List

A data structure that keeps a list of elements of the same type.

```Haskell
data List a = Nil | Cons a (List a)
```

A list can either be empty list `Nil`, or `Cons`, that prepends an element of type `a` to a list of the same type.

A list of type `a` in Haskell is denoted as `[a]`. `Nil` is represented as `[]` and `Cons` - `:`.

```Haskell
> [1, 2, 3]
[1,2,3]
> 1 : 2: 3 : []
[1,2,3]
```

Some common functions:
 - `head [1, 2, 3] = 1`
 - `tail [1, 2, 3] = [2, 3]`
 - `take 2 [1, 2, 3] = [1, 2]`

---
## Ranges

A simple way to create lists of number ranges, is to use the `..` operator.
For example:

```Haskell
> [1..5]
[1,2,3,4,5]
```


We can specify the increment amount for a range by telling the compiler what
the second element of the sequence will be:

```Haskell
> [1,3..11]
[1,3,5,7,9,11]
```

Ranges can be used to create lists of characters:

```Haskell
> ['a'..'f']
"abcdef"
> ['a','c'..'z']
"acegikmoqsuwy"
```

---
## Ranges

We can also create infinite lists of numbers by not specifying the end limit
value for the range, as so:

```Haskell
[1..]
```

Because Haskell is lazy, you can create such lists and the compiler will be
able to handle them.

---
## Checkpoint

So far, we have covered:

- Pure functions
- Total functions
- Defining data types
- Lists
- Ranges

.large[**If you have a question that you haven't asked yet - please do so now before we continue!**]

---
## Going further

Let's look as some more advanced features provided by Haskell:

- Pattern matching
- Strong type system
- Curried functions
- Lambda functions
- Composing two functions
- Higher order functions
- Lazy evaluation

---
## Pattern matching
- powerful alternative for many `if` statements
- functions are written in declarative manner
- destructuring matches

```Haskell
maybeDiv :: Int -> Int -> Maybe Int
maybeDiv _ 0 = Nothing
maybeDiv a b = Just (a `div` b)
```

If the second parameter is `0`, the function will match the first case - `maybeDiv _ 0` and
return `Nothing` as the result - parameters marked with `_` match everything and are ignored.
For all other cases, the second line will match as the default case:
`maybeDiv a b` and capture the argument values as `a` and `b`.

```Haskell
maybeDiv 10 2 == Just 5 -- True
maybeDiv 10 0 == Nothing -- True
```

---
## Pattern matching

Let's create a Fibonacci number generator!

```Haskell
fib :: Integer -> Integer
fib 0 = 1
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
```

 - First the input argument is matched against the literal `0` - if it matches the function returns `1` (`fib 0 = 1`).
 - Otherwise, it is matched against the literal number `1` - if it matches the function returns `1` (`fib 1 = 1`).
 - If the above checks don't match, the input argument is matched against a variable `n`, which will match *any value* that was passed to the function, and place it in the variable `n`. At this point, the variable `n` can be used in the expression on the right side to make recursive calls to `fib` (`fib n = fib (n-1) + fib (n-2)`).

---
## Destructuring matching

```Haskell
maybePlus :: Int -> Maybe Int -> Maybe Int
maybePlus a (Just b) = Just (b + a)
maybePlus _ Nothing = Nothing
```

If the second parameter is a value of `Just t` - a possible value of `Maybe Int` type, it matches
the first case and labels the integer contained in the value as `t`. Alternatively, the second case
matching `maybePlus _ Nothing` will capture all inputs where the second argument is `Nothing`.

```Haskell
maybePlus 10 (Just 5) == Just 15 -- True
maybePlus 10 Nothing == Nothing -- True
```

or, combined with the function defined earlier:

```Haskell
maybePlus 10 (maybeDiv 10 2) == Just 15 -- True
maybePlus 10 (maybeDiv 10 0) == Nothing -- True
```

---
## Strong typing

- *"If it type-checks, it's most likely good"*
- types not only help to ensure that a program works correctly, but also provide a headline of
what a function is doing
- for convenience, most compilers implement type inference

```Haskell
maybePlus :: Int -> Maybe Int -> Maybe Int

...

maybePlus (maybeDiv 10 0) 10
```

```
<interactive>:58:12: error:
    • Couldn't match expected type ‘Int’ with actual type ‘Maybe Int’
    • In the first argument of ‘maybePlus’, namely ‘(maybeDiv 10 0)’
      In the expression: maybePlus (maybeDiv 10 0) 10
      In an equation for ‘it’: it = maybePlus (maybeDiv 10 0) 10
```

---
## Strong typing

```Haskell
map :: (a -> b) -> [a] -> [b]
```

Given the above function signature, we can already say what the function is doing:
 - given a function `(a -> b)`
 - and a list `[a]`
 - it will map over the list, applying the given function and return a list of its return values

Note: the example here uses variable types, and Haskell will infer the actual types based on the
usage of the function - as long as the types marked with the same letter (a or b) are the same, the
function will work correctly.

---
## Curried functions

All functions in Haskell either return the end result or a function to get it:

```Haskell
f :: a -> b -> c
```

`f 3` has type `(b -> c)`, which is a function itself. An example of this can be a sum:

```Haskell
addNumbers x y = x + y
addFive = addNumbers 5
addFive 2 -- will return 7
```

`addNumbers 5` returns a function that takes one parameter `y` and results in `5 + y`.

In Haskell, all functions are curried.

---
## Lambda functions

It is frequently convenient to express simple functions anonymously - without assigning a specific
label to them, but rather just "embedding" them in the function call directly - as seen in the example
below, where 5 is being added to every element of the list.

The syntax to declare a lambda function is: `\parameters -> body`.

```Haskell
map (\x -> x+5) [1..]
```

Why "`\`"? Because `(\` resembles a lambda symbol (if you squint hard enough).

---
## Composing two functions

In Haskell, it is possible to compose two functions to one using the `.` operator:

```Haskell
foo :: Int -> String
foo = show

bar :: String -> [String]
bar x = [x]

foobar = bar . foo

foobar 5  -- ["5"]
```

```Haskell
> :info foobar
foobar :: Int -> [String]
```

`bar` composed with `foo` will call the function `foo` first, and pass its results to the argument of `bar` returning the final results.

---
## Composing two functions

The `.` operator is not a specific language construct - like many others, it is a simple function, defined in the *Prelude*:

```Haskell
(.) :: (b -> c) -> (a -> b) -> (a -> c)
(.) f g = \x -> f (g x)
```

It takes two functions `b -> c` (`f`) and `a -> b` (`g`), and returns a function of type `a -> c`, hiding the intermediate type `b` by passing it directly to the function `f`. As it does not capture the argument of type `a` in the argument list, this implementation uses a *lambda function* to capture it as `x`.

Alternatively, this could be written as:

```Haskell
(.) :: (b -> c) -> (a -> b) -> (a -> c)
(.) f g x = f (g x)
```

Note: *Prelude* is a standard library enabled by default for all Haskell programs.

---
## Higher order functions

Wikipedia:
> In mathematics and computer science, a higher-order function is a function that does at least one of the following:
>
> - takes one or more functions as an input
> - outputs a function

For example, *map* and *fold* (reduce) are very common higher order functions in functional paradigm.

```Haskell
> :type map
map :: (a -> b) -> [a] -> [b]

> :type foldl
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
```

---
## Lazy evaluation

- most programming languages use eager evaluation
- but some start to implement lazy *generators*
- Haskell is **lazy**: it will only compute a value when it is actually used
- memory requirements are less explicit and more difficult to reason about
- however, it is very convenient - allows "infinite" computation definitions (e.g. an infite list is
  expressed as `[1..]`):

```Haskell
> take 5 [1..]
[1,2,3,4,5]
```

---
## ... or even

```Haskell
fibs :: [Integer]
fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
```

.pull-right[![Fibonacci algorithm](assets/fibonacci.jpg)]

This defines a Fibonacci sequence, as an infinite recursive function.

When calculating, e.g. `take 10 fibs`, it will return `[1,1,2,3,5,8,13,21,34,55]`, where:

1. it starts with `[1, 1]`
2. 2 was generated as 1+1 (sum of first and the second values of `fibs`)
3. once we have 2, it generates the next element - this time `1 + 2`
4. and so on, until we get 55 - which is the 10th element.

As we only requested 10 elements, Haskell will stop after calculating the 10th element and will
not be stuck calculating the sequence numbers forever, even
though there is no exit condition defined in the function `fibs`.

---
## Checkpoint

So far, we have covered:

- Pattern matching
- Destructuring matching
- Strong typing
- Curried functions
- Lambda functions
- Composing two functions
- Higher order functions
- Lazy evaluation
- Lazy Fibonacci numbers generator

.large[**If you have a question that you haven't asked yet - please do so now before we continue!**]
---
# A practical example

---
## Let's build an application!

We'll start with a simple one - an application
that prints sorted numerical arguments.

---
## Defining main

```Haskell
main :: IO ()
main = return ()
```

A minimal program that does nothing at all.  It defines an empty `main` function that Haskell uses as the entry point.

You'll notice that it hast type of `IO a` - a context that is allowed to execute I/O functions.

---
## Unit ()

In Haskell `()` is called Unit. Unit is used to denote a type that carries no
information. It is often used when causing side-effects which will have no
useful information to give back. For example:

```Haskell
hello :: IO ()
hello = putStrLn "Hello World"
```
In this case printing a string has no relevant value to return, so it returns
`()`. In this example, `()` is wrapped in the context of `IO` because that's the only context
where side-effects are allowed in Haskell.

---
## The `return` function

```Haskell
main :: IO ()
main = return ()
```

In Haskell, the return value of a function is the result of evaluation the
expression inside of that function. As so, there's is no motive to have a
`return` keyword as you find in other languages.
There is though, a `return` function in Haskell, but it does something
completely different from what you may be used to.

In Haskell, `return` is a function that will give you back a value wrapped inside the
context of the expression it is at. It sounds more complicated than what it
really is. In the example above, it returns `()` in the context of `IO`, so
`IO ()`

---
## IO type

Because Haskell is a pure functional programming language, it does not allow printing, or doing any other side-effects in pure logic functions.

*But how do we implement a useful program then?!*

The answer is - `IO` monad.

---
## Monad?

A simple description is - it allows defining chained actions in a specific context. A convenient way to express such chained actions is using the *do notation*:

```Haskell
worldType :: IO String
worldType = return "Haskell"

main :: IO()
main = do
    whatWorld <- worldType
    let fullText = "hello " ++ whatWorld ++ " world"
    putStrLn fullText
```

---
## Monad

```Haskell
worldType :: IO String
worldType = return "Haskell"

main :: IO()
main = do
    whatWorld <- worldType
    let fullText = "hello " ++ whatWorld ++ " world"
    putStrLn fullText
```

The "Do" notation allows you to extract a value which is inside of a context (the
right side of the `<-` expression), out of that context. This allows you to
use it in a chain of such expressions. The last expression in the do notation,
will be returned as the result, and it needs to be in the same context (in the
above example IO).

---
## App arguments

```Haskell
import System.Environment (getArgs)

main :: IO()
main = do
    args <- getArgs
    return ()
```

To access the program arguments, we will import a standard Haskell function `getArgs` which, as it needs to interact with the environment, is also defined in the `IO` context and returns the arguments as a list of strings:

```
> :info System.Environment.getArgs
System.Environment.getArgs :: IO [String]
```

---
## Sort!

Let's implement our sorting algorithm:

```Haskell
quicksort [] = []
quicksort (p:xs) = (quicksort lesser) ++ [p] ++ (quicksort greater)
    where
        lesser = filter (< p) xs
        greater = filter (>= p) xs
```

While not the most efficient, however a quite simple implementation of a popular sorting algorithm.

Notice, that it does not need to interact with I/O and is considered a *pure* function.

Also, it does not have a function signature! This lets the Haskell compiler to infer the actual types based on both the usage and implementation of the function as we'll see in the further examples.

---
## ...sort

But how can we use it?

```Haskell
main :: IO()
main = do
    args <- getArgs
    putStrLn (quicksort args)
```

An error!

```
test.hs:12:15: error:
    • Couldn't match type ‘[Char]’ with ‘Char’
      Expected type: String
        Actual type: [String]
    • In the first argument of ‘putStrLn’, namely ‘(quicksort args)’
      In a stmt of a 'do' block: putStrLn (quicksort args)
      In the expression:
        do { args <- getArgs;
             putStrLn (quicksort args) }
```

`putStrLn` expects a single string, instead of a list of strings!

---
## Print result

`putStrLn` expects a single string, instead of a list of strings! To fix this, we'll use `intercalate` function imported from the `Data.List` module.

```Haskell
import Data.List (intercalate)

main :: IO()
main = do
    args <- getArgs
    putStrLn (intercalate " " (quicksort args))
```

It's working!

```
> runghc test.hs 10 100 20
10 100 20
```

But what's this? `20` should be before `100`!

---
## Sorting as integers

`20` should be before `100`! The reason, as you might have guessed, is that Haskell sorted the arguments as strings. Let's convert the arguments to integers:

```Haskell
import Data.Maybe (catMaybes)

main :: IO()
main = do
    args <- getArgs
    let integerArgs = (catMaybes (map readMaybe args))::[Int]
    putStrLn (intercalate " " (map show (quicksort integerArgs)))
```

That's better:

```
> runghc test.hs 10 100 20 asd
10 20 100
```

Note: to convert the integers back to strings, we have used the `show` function.

---
## Combine functions

As we have a working application, let's make it a bit nicer. We'll create small, descriptive functions to be able to *read* the program easily:

```Haskell
extractIntegers :: [String] -> [Int]
extractIntegers = catMaybes . map readMaybe

formatString = intercalate " " . map show

sortStringsAsIntegers = formatString . quicksort . extractIntegers

main :: IO()
main = do
    args <- getArgs
    putStrLn (sortStringsAsIntegers args)
```

---
## Final result
```Haskell
import System.Environment (getArgs)
import Data.List (intercalate)
import Text.Read (readMaybe)
import Data.Maybe (catMaybes)

quicksort [] = []
quicksort (p:xs) = (quicksort lesser) ++ [p] ++ (quicksort greater)
    where
        lesser = filter (< p) xs
        greater = filter (>= p) xs

extractIntegers :: [String] -> [Int]
extractIntegers = catMaybes . map readMaybe

formatString = intercalate " " . map show

sortStringsAsIntegers = formatString . quicksort . extractIntegers

main :: IO()
main = do
    args <- getArgs
    putStrLn (sortStringsAsIntegers args)
```

---
## Checkpoint

In this section we have looked at:

- Defining main
- Unit ()
- The `return` function
- IO type
- Monad
- App arguments
- Quicksort algorithm
- Print results
- Converting to integers

.large[**If you have a question that you haven't asked yet - please do so now before we continue!**]

---
# N-Grams example

---
## What is an n-gram?

An n-gram is a continuous sequence of *n* items from a given sample of text.

For example, a list of tri-grams:

```
An n-gram is
n-gram is a
is a continuous
...
```

We can represent it as trees with probabilities of word occurrence:

```
I ------> am -----> going  (100%)

am -----> going --> to     (50%)
                `-> home   (50%)

going --> to -----> work   (50%)
      |      `----> school (50%)
      |
      `-> home ---> [END]  (100%)
```

---
## How can we use it?

```
I ------> am -----> going  (100%)

am -----> going --> to     (50%)
                `-> home   (50%)

going --> to -----> work   (50%)
      |      `----> school (50%)
      |
      `-> home ---> [END]  (100%)
```

We can use this model as a *Markov chain* (from Oxford dictionaries):

> A stochastic model describing a sequence of possible events in which the probability of each event depends only on the state attained in the previous event.

This allows us to generate sentences, resembling the text used to generate tri-grams, although the semantics of the result will be lost.

---
## Let's define our type

We'll use a multi-branched tree structure, where, starting from the root of the tree, we can "drill down" to the n-gram statistics by selecting the next word in the n-gram.

```haskell
data Tree a b = Tree !(Map a (Tree a b)) !b deriving (Show)

type NGrams = Tree String Integer
```

First, we define a generic `Tree` type, that contains a value of type `b` and a map, where keys are of a given type `a`, and values - a recursive definition of the same type `Tree a b`.

But hey! What's that `!`? Haskell, being a lazy language, does not alway calculate the results and put in variables. Instead, the default behaviour is for variables to hold information how to calculate the value, and only calculate it when it is needed for the first time (*Laziness*). `!` makes this type to calculate the values immediately, instead of deferring it. It is called the *Strictness operator*.

Our `NGrams` type is simply a type alias to a `Tree` type, where the key is going to be a `String` and the value for each node - an `Integer`. We'll use it as a counter to tell how many times has this n-gram occurred in our text.

---
## Adding text (single n-gram)

We'll start from an empty `NGrams` instance:
```haskell
emptyNGrams = Tree M.empty 0
```

It is simply an empty tree, with `0` as the occurrence counter. Let's now define a function that can add an NGram (list of words) to the data structure.

```haskell
addNGram :: NGrams -> [String] -> NGrams
addNGram (Tree ngramsMap amount) (word:ws) =
    Tree (M.alter addToNGramsMap word ngramsMap) (amount + 1)
    where addToNGramsMap Nothing  = Just $ addNGram emptyNGrams ws
          addToNGramsMap (Just m) = Just $ addNGram m ws
addNGram (Tree ngramsMap amount) [] = Tree ngramsMap (amount + 1)
```

We use pattern matching, also destructure the ngram argument to the first `word` and the rest (`ws`).

---
## Adding text (single n-gram)

Let's check both cases separately:

```haskell
addNGram (Tree ngramsMap amount) (word:ws) =
    Tree (M.alter addToNGramsMap word ngramsMap) (amount + 1)
    where addToNGramsMap Nothing  = Just $ addNGram emptyNGrams ws
          addToNGramsMap (Just m) = Just $ addNGram m ws
```

- If there was no element with the given word already, then we'll recursively add `ws` to an empty `NGrams` and update the `Tree` for the given word with the result.
- If there was an existing `Tree` for the given word we'll add the rest of the words (`ws`) to it.

Importantly, both cases also increment the counter - `amount + 1`.

```haskell
addNGram (Tree ngramsMap amount) [] = Tree ngramsMap (amount + 1)
```

Once the recursion comes to the state where the list of words is empty, we'll simply increment the amount (to denote that the state was visited during word addition), and leave the map as it was.

---
## Adding text (single n-gram)

Once we have added a few n-grams, our `NGrams` structure looks like this:

![NGrams structure](assets/ngrams_structure.jpg)

---
## Loading text content

We'll define a function, that takes an integer `n` - to generate n-grams, input text as a `String`, and will return the generated `NGrams` structure.

```haskell
loadText :: Int -> String -> NGrams
```

To implement it, we'll need to clean up the input text, generate ngrams, and add them all to an empty `NGrams` structure. All this is done by the line here:

```haskell
loadText n = foldl addNGram emptyNGrams . ngrams . filtered
```

Of course, we'll need to define the actual functions:

```haskell
    where
        filtered =  nlToSpace . filter (/= '\r')

        ngrams = fmap (take n) . tails . words

        nlToSpace []           = []
        nlToSpace ('-':'\n':s) = nlToSpace s
        nlToSpace ('\n':s)     = ' ':nlToSpace s
        nlToSpace (x:xs)       = x:nlToSpace xs
```

---
## Loading text content

Let's look at them one by one:

```haskell
filtered = nlToSpace . filter (/= '\r')
```

We'll remove all carriage return characters (`\r`), and join new lines with spaces:

```haskell
nlToSpace []           = []
nlToSpace ('-':'\n':s) = nlToSpace s
nlToSpace ('\n':s)     = ' ':nlToSpace s
nlToSpace (x:xs)       = x:nlToSpace xs
```

`nlToSpace` is a recursive function, as it needs some more context for pattern matching - e.g. if a line ends with a `-` the function will not add a space, but will just remove both the dash `-` and the following new line character `\n`.

---
## Loading text content

To generage n-grams, we split the input string to words, and return all possible tails of a given list, later reducing each tail to the size of the requested `n`.

```haskell
ngrams = fmap (take n) . tails . words
```

![NGrams generation](assets/ngrams.jpg)

---
## Loading text content

The last step is to add all generated ngrams to an empty `NGrams` data structure:

```haskell
foldl addNGram emptyNGrams ngrams
```

We have already defined the `addNGram` before, so now we just need to *fold* that function for all generated ngrams.

```haskell
class Foldable (t :: * -> *) where
    foldl :: (b -> a -> b) -> b -> t a -> b
```

A `class`? Yes, it's a typeclass.

---
## What's a type class?
.subheader2[we'll return to the example soon]

From "Learn You a Haskell for Great Good!":

> A typeclass is a sort of interface that defines some behavior. If a type is a part of a typeclass, that means that it supports and implements the behavior the typeclass describes. A lot of people coming from OOP get confused by typeclasses because they think they are like classes in object oriented languages.

Typeclasses are:
- similar to interfaces/abstract classes in OO
- can have default implementation

```haskell
countSame :: Eq a => a -> [a] -> Int
```

- `a` is a variable type - we can call it with any types that satisfy the constraints (that have an
  instance of `Eq` type class defined for them).
- `Eq` is a typeclass that we require for the type `a`. It is defined by the Haskell library, and
specifies that the equality functions for the type `a` are defined (`==`), otherwise it will not
compile.

---
## What's a type class?
.subheader2[we'll return to the example soon]

```haskell
countSame :: Eq a => a -> [a] -> Int
```

Given the above function signature, we can say that:

- we only require **to be able** to compare variables of type `a`
- we only **can** compare the variables of type `a`
- **the same type** `a` has to be passed to the 1st and 2nd params

---
## What's a type class?
.subheader2[we'll return to the example soon]

Typeclasses are defined like this:

```haskell
class  Eq a  where
    (==), (/=)           :: a -> a -> Bool

    x /= y               = not (x == y)
    x == y               = not (x /= y)
```

The users of a library can choose which function to implement - `==` or `/=`, because the other one will then be able to use the default behaviour of negating the implemented one.

Creating new instances:

```haskell
data MyType = MyType Int

instance Eq MyType where
    (MyType a) == (MyType b) = a == b
```

---
## What's a type class?
.subheader2[we'll return to the example soon]

Usage in functions:

```haskell
countSame :: Eq a => a -> [a] -> Int
countSame x = foldl (\s el -> if el == x then s + 1 else s) 0
```

Back to *fold*!

```haskell
class Foldable (t :: * -> *) where
    foldl :: (b -> a -> b) -> b -> t a -> b
```

It takes a function that takes a `b` and an `a` and returns a `b` - after applying the `a` to the original `b`, `foldl` then takes an initial `b` value, and a `t a`, where `t` is `Foldable` (in our example it is a list) and contains values of `a`. The fold function then goes through all of the values `a` in our list, and applies to the `b` value, always accumulating the result.

Let's try with `countSame` - `foldl` takes a function `(\s el -> if el == x then s + 1 else s)` - which takes `s` and `el` - and if `el` is equal to the parameter given earlier, it increments `s` by returning `s + 1` or leaves it the same as before. `foldl` will start with the initial value of `0`, and the last parameter - the `[a]` is going to be passed when invoking `countSame` (remember currying?).

---
## Loading text content

Let's check our `loadText` again:

```haskell
loadText :: Int -> String -> NGrams
loadText n = foldl addNGram emptyNGrams . ngrams . filtered
    where
        filtered =  nlToSpace . filter (/= '\r')

        nlToSpace []           = []
        nlToSpace ('-':'\n':s) = nlToSpace s
        nlToSpace ('\n':s)     = ' ':nlToSpace s
        nlToSpace (x:xs)       = x:nlToSpace xs

        ngrams = fmap (take n) . tails . words
```

We can read it now as:

- We'll fold over the ngrams from the filtered input string with addNGram, starting with emptyNGrams;
- *where* by filtering we mean to just remove the carriage returns and convert new lines to spaces;
- ngrams are simply tails of words from the given string, all limited to the requested length.
---
## Generating new sentences

So now that we have an `NGrams` structure populated with data, how do we use it?

Let's look at what are we going to need:

- we'll need to know the n for n-grams that we expect to generate,
- also the ngrams data,
- a number of words that we should generate,
- and a source of random numbers, to be used to select words.

We'll return the generated text as a string.

In Haskell this could look like this:

```haskell
generateSample :: Int -> NGrams -> Int -> [Double] -> String
generateSample n ngrams wordLimit rands = undefined
```

---
## Generating new sentences

Let's assume that we have a function that generates the next word given the last (n-1):
```haskell
generateNextWord :: NGrams -> [String] -> Double -> Maybe String
generateNextWord ngrams lastWords rand = undefined
```

How can we use it? One example could be like this:

```haskell
go 0 _ _ = []
go wLimit lastWords (r:rs) = case generateNextWord ngrams (reverse lastWords) r of
    Just w  -> w : go (wLimit - 1) (take (n-1) (w:lastWords)) rs
    Nothing -> []
```

- using recursion to generate up to `wLimit` of words - notice the pattern capture for `0` case and reduction of it when recursing;
- we'll maintain `lastWords` and prepend the last generated word to it when recursing, limiting it's length to `n - 1`;
- we'll use the first random number `r` for generating next word, and pass the rest of them `rs` to generate subsequent words;

*Note:* this example uses `case .. of` pattern matching syntax not mentioned before.

*Question:* why do we use `reverse lastWords` in the `generateNextWord` expression?

---
## Generating new sentences

So now that we have the core implementation of the function, let's wrap it to our expected API:

```haskell
generateSample :: Int -> NGrams -> Int -> [Double] -> String
generateSample n ngrams wordLimit rands = unwords $ go wordLimit [] rands
    where
        go 0 _ _ = []
        go wLimit lastWords (r:rs) =
            case generateNextWord ngrams (reverse lastWords) r of
                Just w  -> w : go (wLimit - 1) (take (n-1) (w:lastWords)) rs
                Nothing -> []
```

`generateSample` is the results of the function go, where all words are joined to a string by `unwords`.

We also see a new Haskell function used here - `$`.

```haskell
($) :: (a -> b) -> a -> b
infixr 0 $
```

The function simply avoids the need of parenthesis `()` around the second argument and generally can be considered as a syntactic helper. The expression `unwords $ go wordLimit [] rands` above could also have been written as `unwords (go wordLimit [] rands)` with exactly the same effect.

---
## Generate next word

.pull-right[![Selecting next word](assets/ngrams_word_selection.jpg)]

We've mentioned before that we'll need to generate the next word, and we'll likely need these arguments for it:

- the populated `NGrams` structure,
- previous words in the n-gram,
- a random number for selecting the next word.

We'll either return the next word as string, or nothing, if we cannot find any suitable words.

Let's think how can we generate the next word (intuitively):

- we should "drill down" in the `NGrams` structure by the given previous words - this leaves us an `NGrams` structure with only those words from the given context;
- we'll select one word from the top level words of that structure;
- to preserve the distribution of words same as in our input texts, we'll use a "weighted roulette" approach:
    - each word is annotated with frequency of it's occurrence *(in red)*;
    - we'll sum (rolling) those frequencies for all words *(in green)*;
    - we'll scale the given "random" number from 0 to the total amount of occurrences *(8)*;
    - and finally we'll pick the first word greater than our scaled random value.

---
## Generate next word

How does this look in Haskell?

First, an empty ngrams data will not produce any words:

```haskell
generateNextWord (Tree _ 0) _ _ = Nothing
```

Otherwise, if we have words in our context, let's drill down to the `NGrams` data:

```haskell
generateNextWord (Tree ngramsMap _) (w:ws) rand =
        generateNextWord (lookupWord w ngramsMap) ws rand
    where
        lookupWord w ngramsMap = fromMaybe emptyNGrams (M.lookup w ngramsMap)
```

---
## Generate next word

Let's start with scaling the random number. We'll expect a floating point number in the range *[0, 1)*, and convert it
to an integer range *[0, amount)*:

```haskell
generateNextWord (Tree ngramsMap amount) [] r = ...
    where
        scaledRandom = floor (r * fromIntegral amount)
```

.pull-right[![Selecting next word](assets/ngrams_word_selection.jpg)]

Great, that was easy! The next step is to select all words with their occurrence amounts *(the red numbers on the right)*:

```haskell
wordsWithAmounts =
    map (\(w, Tree _ wAmount) -> (w, wAmount)) .
        M.toList $ ngramsMap
```

We'll convert the `ngramsMap` to a list, and map it only "pulling out" the word `w` and its occurrence amount `wAmount`.

*Note:* we're using a *tuple* here as our return type - `(w, wAmount)` - it contains both values.

---
## Generate next word

.pull-right[![Selecting next word](assets/ngrams_word_selection.jpg)]

Now that we have extracted words and their occurrence amounts, let's convert them to accumulative occurrence amounts *(the numbers in green on the right)*:

```haskell
accumAmounts = reverse . snd $
    foldl accumAmount (0, []) wordsWithAmounts
where accumAmount (lastAmount, ret) (w, wAmount) =
    let newAmount = wAmount + lastAmount
    in (newAmount, (w, newAmount) : ret)
```

This may not be an optimal solution, but it describes our intuitive solution in Haskell and allows us to run it.

We'll foldl over the `wordsWithAmounts` with an integer accumulator, and replace the amount with the accumulated amount in the function output. Because prepending list is much faster, we'll prepend to our resulting list, thus reversing its order from the original `wordsWithAmounts`. To compensate for that, we'll reverse the output again before returning it.

*Note:* we have introduced another syntax element in this example - `let ... in ...` - which is similar to using `where` in effect, but might look more natural in some expressions.

---
## Generate next word

Now that we have built our "roulette" wheel, let's pick a value from it:

```haskell
pickByRand = take 1 . dropWhile (\(_, a) -> a < scaledRandom)
```

This was quite easy - drop all elements where the accumulator is smaller than our scaled random number, and take the next element (if it exists).

Instead of defining a lambda function, we can also write it by composing curried functions, like this:

```haskell
pickByRand = take 1 . dropWhile ((< scaledRandom) . snd)
```

---
## Generate next word

Finally, the full function to generate the next word:

```haskell
generateNextWord (Tree ngramsMap amount) [] r =
        fmap fst . listToMaybe . pickByRand $ accumAmounts
    where
        scaledRandom = floor (r * fromIntegral amount)
        pickByRand = take 1 . dropWhile ((< scaledRandom) . snd)
        accumAmounts = reverse . snd $ foldl accumAmount (0, []) wordsWithAmounts
            where accumAmount (lastAmount, ret) (w, wAmount) =
                    let newAmount = wAmount + lastAmount
                    in (newAmount, (w, newAmount) : ret)
        wordsWithAmounts =
            map (\(w, Tree _ wAmount) -> (w, wAmount)) . M.toList $ ngramsMap
```

---
## Joining it all together

Now that we have defined all required functions, let's coordinate them to run our application:

```haskell
main :: IO ()
main = do
    inputHandle <- openFile "./data/combined.txt" ReadMode
    hSetEncoding inputHandle char8
    hSetEncoding stdout char8
    corp <- hGetContents inputHandle
    let triGrams = loadText 3 corp
    g <- newStdGen
    let sample = generateSample 3 triGrams 10000 (randoms g)
    putStrLn sample
```

*Note:* retrieving random numbers is an `IO` action, so we are only allowed to call it in this context, however, we can ask here to retrieve an infinite stream of random numbers, and use it later in our functions (which we have done already).

---
## Example output

**Trigrams sourced from *Project Gutenberg* books (1355680 words):**

- Ada Leverson: "Tenterhooks"
- Bob Evans: "The Forest Monster of Oz"
- Boswell: "Life Of Johnson, Volume 4 (of 6)"
- Carolyn Wells: "Patty at Home"
- Charles Lamb: "The Works of Charles and Mary Lamb, Volume 2"
- Daniel Drayton: "Personal Memoir Of Daniel Drayton"
- Euripides: "The Trojan women of Euripides"
- Frances Elliot: "The Italians"
- James Otis: "The Minute Boys of the Mohawk Valley"
- John R. Musick: "The Real America in Romance, Volume 6; A Century Too Soon (A Story"
- Louis Hughes: "Thirty Years a Slave"
- S. H. Hammond: "Wild Northern Scenes"
- Talbot Mundy: "Affair in Araby"
- Thomas F. A. Smith: "What Germany Thinks"
- Various: "Punchinello, Vol. 2, No. 27, October 1, 1870"
- Various: "Punchinello, Vol. II., Issue 31, October 29, 1870"
- Walter Kellogg Towers: "Masters of Space"

---
## Example output

**The result:**

With an air of indifference answered, 'A mere trifle Sir, not sensible in every department of its prime, and it does look almost as white as snow, his frame hardened by early severities and wholesome fatigue that he would try for it pleased GOD to restore the Lunechien Forest." "The Lunechien Forest?" echoed the Forest Monster. "In any case," said Spalding, "you are drawing a distinction not warranted by the Peruvian-bark are innumerable. But it was a letter.

This prisoner is charged with condoning perjury in order to keep up on the stairs. "Now my cup of tea in an hour, and landing him safely in from all liability, costs and expenses, including legal fees. YOU AGREE THAT THE FOUNDATION, THE TRADEMARK OWNER, AND ANY DISTRIBUTOR UNDER THIS AGREEMENT WILL NOT BE LIABLE TO YOU FOR ACTUAL, DIRECT, INDIRECT, CONSEQUENTIAL, PUNITIVE OR INCIDENTAL DAMAGES EVEN IF YOU GIVE NOTICE OF THE BEHAVIOUR OF MARRIED PEOPLE As a rule in every direction; and if he means no harm, Bruce. I couldn't live with us." "Humph, I suppose you don't have to make inquiries of the founders of Jamestown Berkeley demands surrender of a mechanically or motor driven mechanism which causes police and denounced.

---
## Checkpoint

We've looked at:

- What is an n-gram and how can we use it?
- Creating custom `Tree` types
- Loading text to `NGrams` data and generating text from it
- Typeclasses!

.large[**If you have a question that you haven't asked yet - please do so now before we continue!**]

---
## Quiz time!

- how to improve performance of generating the next word?

---
## Improved word selection

Instead of building the accumulated sums, we can directly reduce the limited until we reach 0 or less - we'll know then that we have reached the word on our roulette and can return it immediately (instead of continuing to accumulate numbers):

```haskell
generateNextWord (Tree ngramsMap amount) [] r =
        selectByAmountLim scaledRandom wordsWithAmounts
    where
        scaledRandom = floor (r * fromIntegral amount)
        selectByAmountLim _ [] = Nothing
        selectByAmountLim lim ((w, wAmount):ws)
            | nextLim <= 0 = Just w
            | otherwise = selectByAmountLim nextLim ws
            where nextLim = lim - wAmount
        wordsWithAmounts =
            map (\(w, Tree _ wAmount) -> (w, wAmount)) . M.toList $ ngramsMap
```

---
# Functional programming concepts

---
## Monoids

```haskell
class Monoid a where
    mempty  :: a
    -- ^ Identity of 'mappend'
    mappend :: a -> a -> a
    -- ^ An associative operation
    mconcat :: [a] -> a
    mconcat = foldr mappend mempty
```

A monoid is a category where a given type has an operation that combines two elements of the same type to a third one. There also must by an identity element.

For example, all integers are monoids when summing them (identity is `0`), e.g. `1 + 2 = 3`.

Also, all integers are monoids when multiplying them, with identity `1`.

---
## Monoid laws

- Identity law
    - `mappend mempty x` = `x`
    - `mappend x mempty` = `x`
- Associative law
    - `mappend x (mappend y z)` = `mappend (mappend x y) z`

Following the summed integers example, the above can be seen as:
- Identity law
    - `0 + x` = `x`
    - `x + 0` = `x`
- Associative law
    - `x + (y + z)` = `(x + y) + z`


---
## Monoid example

Some haskell examples:

```haskell
Sum 4 <> Sum 3 <> Sum 2 <> Sum 1
--    Sum{getSum = 10}
```

```haskell
mconcat . (map Sum) $ [1..4]
--    Sum{getSum = 10}
```

Or, let's combine `Sum` and `Maybe`:

```haskell
mconcat . (map $ Just . Sum) $ [1..4]
--    Just (Sum{getSum = 10})
```

```haskell
Just (Sum 10) <> Nothing <> Just (Sum 5)
--    Just (Sum{getSum = 15})
```


---
## Functors

Functors allows mapping over them:

```haskell
class Functor f where
    fmap :: (a -> b) -> f a -> f b
```

We have used it earlier when generating ngrams already:

```haskell
ngrams = fmap (take n) . tails . words
```

???

- The functor is the computation context
- fmap takes a function, and a value in the context
- then fmap applies the function to an unwrapped value
- and returns wrapped result

---
## Functor laws

- identity:
    - `fmap id` = `id`
- composition:
    - `fmap (p . q)` = `(fmap p) . (fmap q)`


When the mapped function does not change the data, the full data structure must not change as well.

When mapping a function over a data structure, we can choose to split it and map the second part later or vice versa.

---
## Example

```haskell
numbers = [1..10]
strings = fmap show numbers
-- ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"]

notSureIfNumber = Just 9
notSureIfString = fmap show notSureIfNumber
-- Just "9"

notSureIfNumber = Nothing
notSureIfString = fmap show notSureIfNumber
-- Nothing
```


---
## Applicative functors

- applicative functor is a functor accepting wrapped functions
- it's definition:

```haskell
class Functor f => Applicative f where
pure :: a -> f a
(<*>) :: f (a -> b) -> f a -> f b
(*>) :: f a -> f b -> f b
(<*) :: f a -> f b -> f a
```

It's simply a `Functor` with a function inside! For example:

```haskell
f a b = a + b
y = fmap f (Just 1)
y <*> (Just 2)
```
```
Just 3
> :t f
f :: Num a => a -> a -> a
> :t y
y :: Num a => Maybe (a -> a)
```


???

- same as functor, however allows the function to be wrapped too!
- unwraps the function and the argument
- "unwrapping" means to execute the context rules, take the value
- applies the function
- wraps the result back

---
## Applicative functor example

- apply a "boxed" function to a "boxed" value:

```haskell
Just (+1) <*> Just 1                 -- Just 2
```

- apply a binary function:

```haskell
Just (+) <*> Just 1 <*> Just 4       -- Just 5
```

```haskell
Just (+) <*> Just 1 <*> Nothing      -- Nothing
```

- a shorthand for fmap:

```haskell
(+) <$> Just 1 <*> Just 4            -- Just 5
```


---
## Monads

```haskell
class  Monad m  where
    return      :: a -> m a
    (>>=)       :: m a -> (a -> m b) -> m b
    (>>)        :: m a -> m b -> m b

    m >> k      = m >>= \_ -> k
```

???

- `return` - Inject a value into the monadic type.
- `(>>=)` - Sequentially compose two actions, passing any value produced by the first as an argument to the second.
- `(>>)` - Sequentially compose two actions, discarding any value produced by the first, like sequencing operators (such as the semicolon) in imperative languages.

---
## Monad laws

- identity:
    - `return a >>= k`  =  `k a`
    - `m >>= return`  =  `m`
- associativity:
    - `m >>= (\x -> k x >>= h)`  =  `(m >>= k) >>= h`

---
## Maybe monad

```haskell
Just 1 >>= (\a -> return $ a+1)  -- or just "Just 1 >>= return . (+1)"
-- Just 2
```

The `do` notation is just syntactic sugar over `>>=`!

```haskell
computation :: Maybe Int
computation = do
    a <- Just 1
    return $ a + 1
```

---
## Checkpoint

We've looked at:

- Monoids
- Functors
- Applicative functors
- Monads

.large[**If you have a question that you haven't asked yet - please do so now!**]

---
# Thanks!

.top-right[![Haskell logo](assets/haskell_logo.png)]
</textarea>
    <script src="remark.js"></script>
    
    <script>
      window.slideshow = remark.create({"highlightStyle":"docco","navigation":{"scroll":false}})
    </script>
    <script>
      
    </script>
  </body>
</html>
